"use strict";(globalThis.webpackChunk_w5s_website=globalThis.webpackChunk_w5s_website||[]).push([[1283],{1184(e,n,a){a.d(n,{R:()=>c,x:()=>l});var t=a(4041);const s={},r=t.createContext(s);function c(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(r.Provider,{value:n},e.children)}},2940(e,n,a){a.d(n,{n:()=>o});var t=a(2436),s=a(2196),r=a(396);const c="badge_qV9W",l="apiLink_d4om";var i=a(1085);function o(e){const n=(0,r.default)(),{siteConfig:a}=n;return(0,i.jsxs)(i.Fragment,{children:[null==e.apiHref?null:(0,i.jsxs)(t.default,{className:l,to:`${a.url}${a.baseUrl.replace(/\/$/,"")}${e.apiHref}`,children:["API ",(0,i.jsx)(s.A,{})]}),["npm-version","npm-license","bundle-size"].map(a=>(({siteConfig:e},n,a)=>{const t={className:c,key:a.badgeType},s=a.badgeStyle??"flat-square";if(null!=n.packageName)switch(a.badgeType){case"bundle-size":return(0,i.jsx)("img",{...t,alt:"Bundle size",src:`https://img.shields.io/bundlephobia/minzip/${encodeURIComponent(n.packageName)}?style=${s}`});case"npm-license":return(0,i.jsx)("img",{...t,alt:"NPM License",src:`https://img.shields.io/npm/l/${encodeURIComponent(n.packageName)}?style=${s}`});case"npm-version":return(0,i.jsx)("img",{...t,alt:"Github version",src:`https://img.shields.io/npm/v/${encodeURIComponent(n.packageName)}?style=${s}`})}return""})(n,e,{badgeType:a}))]})}},8470(e,n,a){a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"packages/task/cancelling-tasks","title":"Cancelling Tasks","description":"Stopping running tasks and freeing resources","source":"@site/docs/packages/3-task/cancelling-tasks.mdx","sourceDirName":"packages/3-task","slug":"/packages/task/cancelling-tasks","permalink":"/std/docs/packages/task/cancelling-tasks","draft":false,"unlisted":false,"editUrl":"https://github.com/w5s/std.git/tree/main/apps/website/docs/packages/3-task/cancelling-tasks.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Running Tasks","permalink":"/std/docs/packages/task/running-tasks"},"next":{"title":"Time","permalink":"/std/docs/category/time"}}');var s=a(1085),r=a(1184),c=a(2940);const l={sidebar_position:4},i="Cancelling Tasks",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Making a Task Cancellable",id:"making-a-task-cancellable",level:2},{value:"Basic Pattern",id:"basic-pattern",level:3},{value:"With Fetch API (AbortController)",id:"with-fetch-api-abortcontroller",level:3},{value:"With Task.from (Low-level)",id:"with-taskfrom-low-level",level:3},{value:"Triggering Cancellation",id:"triggering-cancellation",level:2},{value:"Using a Canceler Ref",id:"using-a-canceler-ref",level:3},{value:"Timeout Pattern",id:"timeout-pattern",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Always Clean Up Resources",id:"always-clean-up-resources",level:3},{value:"Check for Cancellation in Long Operations",id:"check-for-cancellation-in-long-operations",level:3},{value:"Propagate Cancellation to Subtasks",id:"propagate-cancellation-to-subtasks",level:3},{value:"FAQ",id:"faq",level:2}];function u(e){const n={admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{Details:a}=n;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"cancelling-tasks",children:"Cancelling Tasks"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Stopping running tasks and freeing resources"}),"\n"]}),"\n",(0,s.jsx)(c.n,{apiHref:"/api/task/namespace/task"}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"One of the key features of Tasks is their ability to be cancelled. Cancellation means that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The current execution does not need to resolve or reject"}),"\n",(0,s.jsx)(n.li,{children:"The execution can be stopped"}),"\n",(0,s.jsx)(n.li,{children:"Resources can be freed (timers, network requests, file handles, etc.)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"making-a-task-cancellable",children:"Making a Task Cancellable"}),"\n",(0,s.jsxs)(n.p,{children:["Any task can be configured as cancellable by setting the ",(0,s.jsx)(n.code,{children:"canceler.current"})," value with a callback function."]}),"\n",(0,s.jsx)(n.h3,{id:"basic-pattern",children:"Basic Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Task } from '@w5s/task';\n\nconst cancellableTask = Task.create(({ canceler }) => {\n  // Setup your async operation\n  const timeoutId = setTimeout(() => {/* ... */}, 1000);\n  \n  // Define what happens when cancelled\n  canceler.current = () => {\n    clearTimeout(timeoutId);\n    console.log('Task was cancelled');\n  };\n  \n  return Task.ok('result');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"with-fetch-api-abortcontroller",children:"With Fetch API (AbortController)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Task } from '@w5s/task';\n\nconst fetchAPIData = (): Task<string, NetworkError> => Task.create(async ({ canceler }) => {\n  const abortController = new AbortController();\n  // Set the canceler to abort the request when the task is cancelled\n  canceler.current = () => abortController.abort();\n\n  try {\n    const response = await fetch('/api/data', { signal: abortController.signal });\n    return Task.ok(await response.text());\n  } catch (error) {\n    return Task.error(new NetworkError({ cause: error }));\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"with-taskfrom-low-level",children:"With Task.from (Low-level)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Task } from '@w5s/task';\n\nconst delayedTask = Task.from(({ resolve, reject, canceler }) => {\n  const timeoutId = setTimeout(() => resolve(42), 1000);\n  \n  // Setup cancellation\n  canceler.current = () => clearTimeout(timeoutId);\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"triggering-cancellation",children:"Triggering Cancellation"}),"\n",(0,s.jsx)(n.h3,{id:"using-a-canceler-ref",children:"Using a Canceler Ref"}),"\n",(0,s.jsxs)(n.p,{children:["Pass a canceler reference to ",(0,s.jsx)(n.code,{children:"Task.run"})," to be able to cancel the task later:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Task } from '@w5s/task';\n\n// Create a canceler reference\nconst controller = new AbortController();\n\n// Start the task with the canceler\nconst resultPromise = Task.run(longRunningTask, { signal: controller.signal });\n\n// Cancel after 5 seconds\nsetTimeout(() => {\n  controller.abort();\n}, 5000);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"timeout-pattern",children:"Timeout Pattern"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"@w5s/task-timeout"})," to automatically cancel a task after a delay:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Task } from '@w5s/task';\nimport { timeout } from '@w5s/task-timeout';\nimport { TimeDuration } from '@w5s/time';\n\nconst longTask = fetchLargeData();\n\n// Cancel if not completed within 30 seconds\nconst timeoutTask = timeout(longTask, TimeDuration({ seconds: 30 }));\n\nconst result = await Task.run(timeoutTask);\n// Result.Error(TimeoutError) if task takes longer than 30 seconds\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsx)(n.h3,{id:"always-clean-up-resources",children:"Always Clean Up Resources"}),(0,s.jsx)(n.p,{children:"When creating cancellable tasks, ensure all resources are properly released:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const task = Task.create(async ({ canceler }) => {\n  const connection = await openConnection();\n  const subscription = events.subscribe(handler);\n  \n  // Clean up everything on cancel\n  canceler.current = () => {\n    connection.close();\n    subscription.unsubscribe();\n  };\n  \n  // ... task logic\n});\n"})})]}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsx)(n.h3,{id:"check-for-cancellation-in-long-operations",children:"Check for Cancellation in Long Operations"}),(0,s.jsx)(n.p,{children:"For tasks with multiple steps, check if cancellation was requested:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const processItems = (items: Item[]) => Task.create(async ({ canceler }) => {\n  let isCancelled = false;\n  canceler.current = () => { isCancelled = true; };\n  \n  const results = [];\n  for (const item of items) {\n    if (isCancelled) {\n      // Stop processing if cancelled\n      break;\n    }\n    results.push(await processItem(item));\n  }\n  \n  return Task.ok(results);\n});\n"})})]}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsx)(n.h3,{id:"propagate-cancellation-to-subtasks",children:"Propagate Cancellation to Subtasks"}),(0,s.jsx)(n.p,{children:"When running subtasks, ensure cancellation propagates:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const parentTask = Task.create(async ({ canceler, run }) => {\n  // The `run` function automatically propagates the canceler\n  const result1 = await run(childTask1);\n  const result2 = await run(childTask2);\n  \n  return Task.ok({ result1, result2 });\n});\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)(n.p,{children:"What happens to the result when a task is cancelled?"})}),(0,s.jsxs)(n.p,{children:["When a task is cancelled, it neither resolves nor rejects. The Promise returned by ",(0,s.jsx)(n.code,{children:"Task.run"})," will remain pending unless the task handles cancellation by resolving or rejecting explicitly."]})]}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)(n.p,{children:"Can I know if a task was cancelled?"})}),(0,s.jsx)(n.p,{children:"You can track cancellation state within your task:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const task = Task.create(async ({ canceler }) => {\n  let wasCancelled = false;\n  \n  canceler.current = () => {\n    wasCancelled = true;\n    console.log('Task was cancelled');\n  };\n  \n  // ... task logic\n  \n  if (wasCancelled) {\n    return Task.error(new CancelledError());\n  }\n  \n  return Task.ok(result);\n});\n"})})]}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)(n.p,{children:"Does cancellation work with async/await?"})}),(0,s.jsxs)(n.p,{children:["Yes, but you need to handle it properly. When using ",(0,s.jsx)(n.code,{children:"AbortController"})," with fetch or similar APIs, the abort will cause the Promise to reject with an ",(0,s.jsx)(n.code,{children:"AbortError"}),":"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const task = Task.create(async ({ canceler }) => {\n  const abortController = new AbortController();\n  canceler.current = () => abortController.abort();\n\n  try {\n    const response = await fetch('/api', { signal: abortController.signal });\n    return Task.ok(await response.json());\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      // Handle cancellation specifically\n      return Task.error(new CancelledError());\n    }\n    return Task.error(new NetworkError({ cause: error }));\n  }\n});\n"})})]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);